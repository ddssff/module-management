Unsupported:

   CPP directives.  It is difficult to see how this could be implemented.

Bugs:

  1. If you have a standalone derived instance of a type alias, it won't
     notice that the constructors of the original type are required.  E.g.:

       import Some.Module (Bar(..))
       type Foo Bar
       deriving instance Show Foo

     With this input, cleanImports will remove the "(..)" from the Bar import
     and the resulting file will not compile.  "deriving instance Show bar"
     will work correctly.

  2. If the symbols used by a standalone derived instance are imported by an
     import line with no specs, cleanImports with fail.  Add explicit imports
     by hand before running cleanImports.

  3. Leaves behind some .imports files

  4. Template haskell will frequently mess it up

To Do:

  1. Make sure original file is left as backup, not some intermediate
  3. SplitModule should not create a re-exporter, it needs to update
     the imports of the moduVerse the way catModules does.
  4. splitModule should create an UnExported module for symbols that
     were previously private, and a Symbols module for symbols that
     can't be made into module names, and a ReExported module for
     symbols that were not declared in the original, just imported and
     re-exported.
  5. Do global check whether export symbols are imported anywhere, and
     if not remove them.

Questions:

  1. Does GHC omit Prelude imports even when NoImplicitPrelude option is given?
